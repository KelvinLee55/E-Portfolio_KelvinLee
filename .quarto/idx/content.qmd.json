{"title":"Content & Deliverables","markdown":{"yaml":{"title":"Content & Deliverables","format":"html","editor":"visual"},"headingText":"1) Community Project - Disaster Response Mapping","containsRefs":false,"markdown":"\n\n\nThe aim of this project is to create an interactive map that is readily operable and accessible for Mudge Island residents and volunteers, particularly non-GIS users, in both online and offline circumstances. I set up a free QField account that people can use to update and review the map on their computers or phones anytime, anywhere. Map users can click to access the information they need, such as the precise location of water caches and evacuation points by boat or helicopter. This interactive map has proven invaluable in wildfire response decision-making and enhancing familiarity with the island's environment. The map below is just a demo to show the map's potential.\n\n```{r DRM-leaflet, include = FALSE}\nlibrary(terra)\nlibrary(raster)  # for Leaflet compatibility\nlibrary(leaflet)\n\n## --- Map view defaults -------------------------------------------------------\nmudge_lng <- -123.7910\nmudge_lat <-  49.1290\nzoom_lvl  <- 14\n\n## --- Load rasters ------------------------------------------------------------\nhill   <- rast(\"Maps_Kelvin/Hillshade.tif\")\nslope  <- rast(\"Maps_Kelvin/Slope.tif\")\naspect <- rast(\"Maps_Kelvin/Aspect.tif\")\n\n## --- Load vectors ------------------------------------------------------------\nparcel  <- vect(\"Maps_Kelvin/Parcel.gpkg\")  # use the fixed GeoPackage\nroads   <- vect(\"Maps_Kelvin/Roads.gpkg\")\nwater   <- vect(\"Maps_Kelvin/WaterStorage.gpkg\")\naccess  <- vect(\"Maps_Kelvin/AccessPoints.gpkg\")\naddress <- vect(\"Maps_Kelvin/AddressPoints.gpkg\")\n\n## --- Reproject everything to lat-long (WGS84) --------------------------------\ntarget_crs <- \"EPSG:4326\"\n\nhill    <- project(hill,    target_crs)\nslope   <- project(slope,   target_crs)\naspect  <- project(aspect,  target_crs)\n\nparcel  <- project(parcel,  target_crs)\nroads   <- project(roads,   target_crs)\nwater   <- project(water,   target_crs)\naccess  <- project(access,  target_crs)\naddress <- project(address, target_crs)\n\n## --- Hillshade reclassification ---------------------------------------------\nhill <- classify(hill, matrix(c(\n   1,  85, 1,\n  85, 170, 2,\n 170, 255, 3\n), ncol = 3, byrow = TRUE))\n\nlevels(hill) <- data.frame(\n  value = 1:3,\n  label = c(\"Low illumination\", \"Medium illumination\", \"High illumination\")\n)\n\n## --- Slope reclassification --------------------------------------------------\nslope <- classify(slope, matrix(c(\n   0,   5, 1,\n   5,  15, 2,\n  15,  30, 3,\n  30,  60, 4,\n  60, Inf, 5\n), ncol = 3, byrow = TRUE))\n\nlevels(slope) <- data.frame(\n  value = 1:5,\n  label = c(\"Flat\", \"Gentle\", \"Moderate\", \"Steep\", \"Very Steep\")\n)\n\n## --- Aspect reclassification -------------------------------------------------\naspect <- classify(aspect, matrix(c(\n   0,  45, 1,\n  45,  90, 2,\n  90, 135, 3,\n 135, 180, 4,\n 180, 225, 5,\n 225, 270, 6,\n 270, 315, 7,\n 315, 360, 1\n), ncol = 3, byrow = TRUE), include.lowest = TRUE)\n\nlevels(aspect) <- data.frame(\n  value = 1:7,\n  label = c(\n    \"North\", \"Northeast\", \"East\", \"Southeast\",\n    \"South\", \"Southwest\", \"West\"\n  )\n)\n\n## --- Color palettes ----------------------------------------------------------\nhill_cols   <- c(\"#2b2b2b\", \"#7f7f7f\", \"#d9d9d9\")\nslope_cols  <- c(\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\")\naspect_cols <- c(\"#2b004f\",\"#3b2b8f\",\"#2f5fb3\",\"#2fa4a9\",\n                 \"#33c27d\",\"#7cd250\",\"#c7e75b\")\n\n## --- Convert rasters to 'raster' objects for Leaflet ------------------------\nhill_raster   <- raster(hill)\nslope_raster  <- raster(slope)\naspect_raster <- raster(aspect)\n\n## --- Create Leaflet map ------------------------------------------------------\nm <- leaflet(options = leafletOptions(preferCanvas = TRUE)) %>%\n  \n  addProviderTiles(\"Esri.WorldImagery\", group = \"Basemap\") %>%\n  \n  ## --- Raster layers ---\n  addRasterImage(hill_raster, colors = hill_cols, opacity = 0.45, group = \"Hillshade\") %>%\n  addRasterImage(slope_raster, colors = slope_cols, opacity = 0.6, group = \"Slope\") %>%\n  addRasterImage(aspect_raster, colors = aspect_cols, opacity = 0.6, group = \"Aspect\") %>%\n  \n  ## --- Vector layers ---\n  addPolygons(\n    data = parcel,\n    fill = FALSE,\n    color = \"white\",\n    weight = 1,\n    popup = ~paste0(\n      \"<b>PID:</b> \", PID_FORMATTED, \"<br>\",\n      \"<b>Parcel Name:</b> \", PARCEL_NAME, \"<br>\",\n      \"<b>Municipality:</b> \", MUNICIPALITY\n    ),\n    group = \"Parcels\"\n  ) %>%\n  \n  addPolylines(\n    data = roads,\n    color = \"yellow\",\n    weight = 2,\n    popup = ~paste0(\n      \"<b>Road:</b> \", ROAD_NAME_FULL, \"<br>\",\n      \"<b>Class:</b> \", ROAD_CLASS\n    ),\n    group = \"Roads\"\n  ) %>%\n  \n  addCircleMarkers(\n    data = water,\n    radius = 6,\n    color = \"cyan\",\n    fillOpacity = 0.9,\n    popup = ~paste0(\n      \"<b>Name:</b> \", Name, \"<br>\",\n      \"<b>Description:</b> \", description\n    ),\n    group = \"Water Storage\"\n  ) %>%\n  \n  addCircleMarkers(\n    data = access,\n    radius = 5,\n    color = \"orange\",\n    popup = ~paste0(\n      \"<b>Access Type:</b> \", AccessType, \"<br>\",\n      \"<b>Location:</b> \", Location\n    ),\n    group = \"Access Points\"\n  ) %>%\n  \n  addCircleMarkers(\n    data = address,\n    radius = 4,\n    color = \"blue\",\n    popup = ~paste0(\n      \"<b>Address:</b> \", ADDRESS, \"<br>\",\n      \"<b>Road:</b> \", ROAD\n    ),\n    group = \"Address Points\"\n  ) %>%\n  \n  ## --- Layer control ---\n  addLayersControl(\n    overlayGroups = c(\n      \"Hillshade\", \"Slope\", \"Aspect\",\n      \"Parcels\", \"Roads\", \"Water Storage\",\n      \"Access Points\", \"Address Points\"\n    ),\n    options = layersControlOptions(collapsed = FALSE)\n  ) %>%\n  \n  ## --- Hide raster layers by default ---\n  hideGroup(c(\"Hillshade\", \"Slope\", \"Aspect\")) %>%\n  \n  addScaleBar(position = \"bottomleft\") %>%\n  \n  ## --- Zoom to Mudge Island coordinates ---\n  setView(lng = mudge_lng, lat = mudge_lat, zoom = zoom_lvl)\n```\n\n```{r DRM-map, echo=FALSE}\nm\n```\n\n# 1) Capstone Project - Fuel type Mapping\n\n## Preliminary Fuel Type Map\n\nIn this project, I used a 15-band composite derived from 12 Sentinel-2 bands and 3 vegetation indices (NDVI, EVI, and NDWI) as a predictor and integrated four reference land cover maps (CCRS, CFS, VRI, and AAFC) into a high-confidence ground-truth map, where each class is agreed upon by at least three out of four sources. The one-directional convolutional neural network (1D-CNN) identifies each pixel by looking at its unique “color signature” across 15 layers of light and calculating a percentage score for each category; it then assigns the pixel to the class that gets the highest percentage, representing its best and most confident guess.\n\n```{r PFTM-leaflet, include = FALSE}\n## --- Fix PROJ path in-session (no system changes) ----------------------------\n## Run these BEFORE loading spatial packages (or at the top of your Quarto)\nSys.unsetenv(\"PROJ_LIB\"); Sys.unsetenv(\"PROJ_DATA\"); Sys.unsetenv(\"GDAL_DATA\")\n\n## Point to a modern PROJ install you actually have (pick ONE you have installed):\nSys.setenv(PROJ_LIB = \"C:/Program Files/QGIS 3.34.15/share/proj\")\n# Sys.setenv(PROJ_LIB = \"C:/OSGeo4W/share/proj\")  # if you use OSGeo4W\n\n# (Optional) some builds also expect GDAL_DATA:\nif (dir.exists(\"C:/Program Files/QGIS 3.34.15/share/gdal\")) {\n  Sys.setenv(GDAL_DATA = \"C:/Program Files/QGIS 3.34.15/share/gdal\")\n}\n\n## --- Libraries ---------------------------------------------------------------\nlibrary(terra)\nlibrary(leaflet)\n\n## --- Load raster -------------------------------------------------------------\nr_path <- \"Maps_Kelvin/Preliminary_FTM.tif\"\nstopifnot(file.exists(r_path))\n\nPre_FTM_raw <- rast(r_path)\n\n## --- Ensure the raster has a real CRS (critical) -----------------------------\n## If the file lacks a CRS tag, set the TRUE CRS of the data here.\n## (Example uses BC Albers; change if your data is something else.)\nif (is.na(crs(Pre_FTM_raw)) || crs(Pre_FTM_raw) == \"\") {\n  crs(Pre_FTM_raw) <- \"EPSG:3005\"  # <-- CHANGE to your raster’s actual CRS if different\n}\n\n## --- Build palette / legend domain -------------------------------------------\nvals <- unique(values(Pre_FTM_raw))\nvals <- vals[!is.na(vals)]\n\nfuel_labels <- c(\"Broadleaf\",\"Conifer\",\"Shrub\",\"Grass\",\"Bare Soil\",\"Urban\",\"Water\")\nfuel_colors <- c(\"#00FF00\",\"#008000\",\"#FF0000\",\"#E69F00\",\"#808080\",\"#FFFFFF\",\"#0000FF\")\n\nif (length(fuel_colors) < length(vals) || length(fuel_labels) < length(vals)) {\n  warning(\"You have more classes in the raster than labels/colors supplied. \",\n          \"Some classes may be unlabeled/uncolored.\")\n}\n\npal <- colorFactor(\n  palette  = fuel_colors,\n  domain   = vals,\n  na.color = \"transparent\"\n)\n\n## --- Map view defaults -------------------------------------------------------\nmudge_lng <- -123.7910\nmudge_lat <-  49.1290\nzoom_lvl  <- 14\n\n## --- Leaflet map -------------------------------------------------------------\nLea_01 <- leaflet() %>%\n  addProviderTiles(\"Esri.WorldImagery\") %>%\n  setView(lng = mudge_lng, lat = mudge_lat, zoom = zoom_lvl) %>%\n  addRasterImage(\n    Pre_FTM_raw,\n    colors  = pal,\n    opacity = 0.8,\n    project = TRUE,        # leaflet/terra reprojects to EPSG:3857\n    method  = \"ngb\",       # categorical classes\n    maxBytes = 16 * 1024^2\n  ) %>%\n  addLegend(\n    pal    = pal,\n    values = vals,\n    title  = \"Fuel Type\",\n    labFormat = labelFormat(transform = function(x) {\n      idx <- suppressWarnings(as.integer(x))\n      out <- rep(NA_character_, length(idx))\n      ok  <- !is.na(idx) & idx >= 1 & idx <= length(fuel_labels)\n      out[ok] <- fuel_labels[idx[ok]]\n      out\n    })\n  ) %>%\n  addScaleBar(position = \"bottomleft\")\n```\n\n```{r PFT-map, echo=FALSE}\nLea_01\n```\n\n## Code Snippets\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n``` (.r)\nlibrary(terra)\n\n# Compute per-pixel agreement count (1–4)\nagree_count <- app(ref_stack, fun = function(x) {\n  if (all(is.na(x))) return(NA)\n  tab <- table(x)\n  return(max(tab))\n})\n\n# Compute modal (most common) class value\nagree_modal <- app(ref_stack, fun = function(x) {\n  if (all(is.na(x))) return(NA)\n  tab <- table(x)\n  return(as.numeric(names(which.max(tab))))\n})\n```\n\n## Python\n\n``` (.python)\nimport numpy as np\n\ndef compute_agreement(ref_stack):\n    bands, H, W = ref_stack.shape\n    flat = ref_stack.reshape(bands, -1)\n\n    agree_count = np.full(flat.shape[1], np.nan)\n    agree_modal = np.full(flat.shape[1], np.nan)\n\n    for i in range(flat.shape[1]):\n        x = flat[:, i]\n        x = x[~np.isnan(x)]\n        if x.size == 0:\n            continue\n\n        vals, cnts = np.unique(x, return_counts=True)\n        j = cnts.argmax()\n        \n        # Compute per-pixel agreement count (1–4)\n        agree_count[i] = cnts[j]\n        \n        # Compute modal (most common) class value\n        agree_modal[i] = vals[j]\n\n    return agree_count.reshape(H, W), agree_modal.reshape(H, W)\n```\n:::\n\n## Biophysical Inputs: Biomass & Dryness indices\n\nI also integrated two biophysical features into my preliminary fuel type map. The above-ground tree biomass map was reclassified into three classes: low (0–150 tons/ha), medium (150–350 tons/ha), and high (\\> 350 tons/ha) biomass. Sentinel-2 spectral bands (B03, BO8), topographic data (DEM, Slope), and PRISM climatic variables (MAT, MAP) were utilized to derive the dryness index and then reclassified into three fuel moisture classes: moist (0.00–0.30), moderate (0.30–0.60), and dry (0.60–1.00). Subsequently, I combined these two maps into a 9-class Biomass-Dryness (BD) Map.\n\n```{r BDM-leaflet, include = FALSE}\nlibrary(terra)\nlibrary(leaflet)\n\n## --- Load raster -------------------------------------------------------------\nBDM_raw <- rast(\"Maps_Kelvin/Biomass_Dryness_Map.tif\")\n\n## --- Ensure the raster has its true CRS (critical) ---------------------------\n## Replace EPSG:3005 with the actual CRS if different.\nif (is.na(crs(BDM_raw)) || crs(BDM_raw) == \"\") {\n  crs(BDM_raw) <- \"EPSG:3005\"   # <-- CHANGE if your data uses another CRS\n}\n\n## --- Prepare classes / palette / labels -------------------------------------\nvals_01 <- unique(values(BDM_raw))\nvals_01 <- vals_01[!is.na(vals_01)]\n\ndryness_labels <- c(\n  \"Moderate-Low\",\n  \"Moderate-Medium\",\n  \"Moderate-High\",\n  \"Dry-Low\",\n  \"Dry-Medium\",\n  \"Dry-High\"\n)\n\ndryness_colors <- c(\n  \"#00FF00\",\n  \"#008000\",\n  \"#FF0000\",\n  \"#FFFF00\",\n  \"#7FFF00\",\n  \"#D2691E\"\n)\n\ncodes <- sort(unique(vals_01))\n\nif (length(codes) == 9 && all(codes %in% 1:9)) {\n  pal_01 <- colorFactor(\n    palette  = dryness_colors,\n    domain   = codes,\n    na.color = \"transparent\"\n  )\n  label_fn <- function(x) {\n    idx <- suppressWarnings(as.integer(x))\n    lab <- rep(NA_character_, length(idx))\n    ok  <- !is.na(idx) & idx >= 1 & idx <= length(dryness_labels)\n    lab[ok] <- dryness_labels[idx[ok]]\n    lab\n  }\n} else {\n  names(dryness_colors) <- as.character(codes)\n  names(dryness_labels) <- as.character(codes)\n  pal_01 <- colorFactor(\n    palette  = unname(dryness_colors[as.character(codes)]),\n    domain   = codes,\n    na.color = \"transparent\"\n  )\n  label_fn <- function(x) dryness_labels[as.character(x)]\n}\n\n## --- Map camera --------------------------------------------------------------\nmudge_lng <- -123.7910\nmudge_lat <-  49.1290\nzoom_lvl  <- 14\n\n## --- Leaflet map (let Leaflet/terra project to EPSG:3857) --------------------\nLea_02 <- leaflet() %>%\n  addProviderTiles(\"Esri.WorldImagery\") %>%\n  setView(lng = mudge_lng, lat = mudge_lat, zoom = zoom_lvl) %>%\n  addRasterImage(\n    BDM_raw,\n    colors   = pal_01,\n    opacity  = 0.8,\n    project  = TRUE,     # <- reproject to Web Mercator on the fly\n    method   = \"ngb\",    # <- categorical data\n    maxBytes = 16 * 1024^2\n  ) %>%\n  addLegend(\n    pal      = pal_01,\n    values   = codes,\n    title    = \"Biomass‑Dryness\",\n    labFormat = labelFormat(transform = label_fn)\n  ) %>%\n  addScaleBar(position = \"bottomleft\")\n```\n\n```{r BD-map, echo=FALSE}\nLea_02\n```\n\n## Code Snippets\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n``` (.r)\n# Combine into Dryness Index (weights sum ≈ 1)\ndryness <- (0.30 * mat_n) +\n  (0.25 * slope_n) +\n  (0.20 * map_n) +\n  (0.15 * ndwi_n) +\n  (0.10 * dem_n)\n\n# Normalize to 0–1\ndryness <- normalize(dryness)\n```\n\n## Python\n\n``` (.python)\nimport numpy as np\n\n# Combine into Dryness Index (same weights as R)\ndryness = (\n    0.30 * mat_n +\n    0.25 * slope_n +\n    0.20 * map_n +\n    0.15 * ndwi_n +\n    0.10 * dem_n\n)\n\n# Min–max normalization (terra::normalize equivalent)\nmin_val = np.nanmin(dryness)\nmax_val = np.nanmax(dryness)\n\ndryness = (dryness - min_val) / (max_val - min_val)\n```\n:::\n\n## Refined Fuel Model Map\n\nThe final fuel type map was generated by first filtering out unburnable areas, such as water and urban surfaces. Next, I employed CNN-based unmixing to identify specific vegetation patterns (e.g., Conifer (CF) & Broadleaf (BL)) and \"mixed\" classes (e.g., Grass-Shrub (GS) & Timber-Shrub-Grass (TSG)). This vegetation data was combined with a BD9 map, which classifies the landscape into nine categories based on biomass levels and dryness. Eventually, the decision matrix cross-references these two layers through a lookup table to assign each pixel a standardized fire behavior code from the Scott and Burgan (2005) system.\n\n```{r FFTM-leaflet, include = FALSE}\nlibrary(terra)\nlibrary(leaflet)\nlibrary(htmltools)\n\n## --- Load raster -------------------------------------------------------------\nSB_raw <- rast(\"Maps_Kelvin/SB_FMI.tif\")\n\n## --- Ensure the raster has a true CRS (critical) -----------------------------\n## Replace EPSG:3005 if your data uses a different CRS.\nif (is.na(crs(SB_raw)) || crs(SB_raw) == \"\") {\n  crs(SB_raw) <- \"EPSG:3005\"   # <-- CHANGE if your data uses another CRS\n}\n\n## --- Domain / codes ----------------------------------------------------------\nvals_02  <- as.vector(values(SB_raw))\nvals_02  <- vals_02[!is.na(vals_02)]\ncodes_01 <- sort(unique(vals_02))\n\n## --- Labels and colors -------------------------------------------------------\nfinal_fuel_labels <- c(\n  \"TL1\",\"TL2\",\"TL3\",\"TL5\",\"TL6\",\"TL9\",\n  \"SH2\",\"SH3\",\"SH4\",\"SH5\",\"SH6\",\"SH7\",\"SH8\",\"SH9\",\n  \"GR2\",\"GR4\",\"GR5\",\"GR6\",\"GR7\",\"GR9\",\n  \"GS1\",\"GS2\",\"GS3\",\"GS4\",\n  \"TU1\",\"TU2\",\"TU3\",\"TU5\"\n)\n\nfinal_fuel_colors <- c(\n  \"#D6C69A\",\"#D6B27A\",\"#4BE28C\",\"#13A7E6\",\"#E63946\",\"#2C67E4\",\n  \"#08B9E6\",\"#D423E6\",\"#80E3E6\",\"#A642E6\",\"#B1E68A\",\"#F0C000\",\n  \"#C16727\",\"#3C67D6\",\"#1F47D6\",\"#5BD6E6\",\"#23A7D6\",\"#E63E4A\",\n  \"#4CE64C\",\"#D63F40\",\"#D6C666\",\"#A6E6A6\",\"#A7E6C3\",\"#D6C09A\",\n  \"#C32ECF\",\"#00A830\",\"#4EDC5B\",\"#52A7D6\"\n)\n\n## If your raster values are **codes** that correspond 1:1 with the label/color order,\n## we can build a named palette to keep mapping stable regardless of which codes appear.\n## For example, if values are 1..28 and match the above order:\n##   1->TL1, 2->TL2, ..., 28->TU5\n## If your codes are *not* 1..28, adjust 'all_codes' accordingly.\nall_codes <- seq_along(final_fuel_labels)       # 1..28 by default\nstopifnot(length(all_codes) == length(final_fuel_labels),\n          length(final_fuel_labels) == length(final_fuel_colors))\n\n# Build named vectors for robust mapping\nnames(final_fuel_labels) <- as.character(all_codes)\nnames(final_fuel_colors) <- as.character(all_codes)\n\n# Subset to the codes present in the raster, preserving names\npresent <- intersect(as.character(all_codes), as.character(codes_01))\npal_02 <- colorFactor(\n  palette  = unname(final_fuel_colors[present]),\n  domain   = as.numeric(present),\n  na.color = \"transparent\"\n)\n\n## --- HTML legend (unchanged) -------------------------------------------------\nlegend_html_multi <- function(title, labels, colors, ncol = 3, font_size = 10) {\n  stopifnot(length(labels) == length(colors))\n  k <- length(labels)\n  # Split indices into ncol roughly-equal groups\n  cuts   <- ceiling(seq(0, k, length.out = ncol + 1))\n  splits <- lapply(seq_len(ncol), function(j) (cuts[j] + 1):cuts[j + 1])\n\n  make_col <- function(idx) {\n    idx <- idx[!is.na(idx)]\n    tags$ul(\n      style = \"list-style:none; padding:0 10px 0 0; margin:0;\",\n      lapply(idx, function(i) {\n        tags$li(\n          style = \"display:flex; align-items:center; margin: 2px 0;\",\n          tags$span(style = paste0(\n            \"display:inline-block;width:10px;height:10px;\",\n            \"border:1px solid #555;margin-right:6px;background:\", colors[i], \";\"\n          )),\n          tags$span(labels[i])\n        )\n      })\n    )\n  }\n\n  tags$div(\n    style = paste0(\n      \"background: rgba(255,255,255,0.92); padding:8px 10px; border-radius:4px; \",\n      \"box-shadow: 0 1px 4px rgba(0,0,0,0.3); \",\n      \"font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif; \",\n      \"font-size:\", font_size, \"px; max-height: 280px; overflow-y:auto;\"\n    ),\n    tags$div(style=\"font-weight:600; margin-bottom:6px;\", title),\n    tags$div(style = \"display:flex; flex-direction:row;\", lapply(splits, make_col))\n  )\n}\n\nleg_html <- legend_html_multi(\n  title  = \"Final Fuel Type Map\",\n  labels = final_fuel_labels,\n  colors = final_fuel_colors,\n  ncol   = 3,\n  font_size = 10\n)\n\n## --- Map view ----------------------------------------------------------------\nmudge_lng <- -123.7910\nmudge_lat <-  49.1290\nzoom_lvl  <- 14\n\nLea_03 <- leaflet() %>%\n  addProviderTiles(\"Esri.WorldImagery\") %>%\n  setView(lng = mudge_lng, lat = mudge_lat, zoom = zoom_lvl) %>%\n  addRasterImage(\n    SB_raw,\n    colors   = pal_02,\n    opacity  = 0.8,\n    project  = TRUE,     # <- let Leaflet/terra project to EPSG:3857\n    method   = \"ngb\",    # <- categorical data\n    maxBytes = 16 * 1024^2\n  ) %>%\n  addControl(html = as.character(leg_html), position = \"topright\") %>%\n  addScaleBar(position = \"bottomleft\")\n```\n\n```{r FFT-map, echo=FALSE}\nLea_03\n```\n\n## Code Snippets\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n``` (.r)\n# Build Lookup table\nlookup <- list(\n  \n  BL = c(\"Dry-Low\"=fuel_ids$TL2, \"Dry-Medium\"=fuel_ids$TL6, \"Dry-High\"=fuel_ids$TL9, \"Moderate-Low\"=fuel_ids$TL2, \"Moderate-Medium\"=fuel_ids$TL6, \"Moderate-High\"=fuel_ids$TL9, \"Moist-Low\"=fuel_ids$TL2, \"Moist-Medium\"=fuel_ids$TL6, \"Moist-High\"=fuel_ids$TL9),\n  \n  CF = c(\"Dry-Low\"=fuel_ids$TL1, \"Dry-Medium\"=fuel_ids$TL3, \"Dry-High\"=fuel_ids$TL5, \"Moderate-Low\"=fuel_ids$TL1, \"Moderate-Medium\"=fuel_ids$TL3, \"Moderate-High\"=fuel_ids$TL5, \"Moist-Low\"=fuel_ids$TL1, \"Moist-Medium\"=fuel_ids$TL3, \"Moist-High\"=fuel_ids$TL5),\n  \n  SH = c(\"Dry-Low\"=fuel_ids$SH2, \"Dry-Medium\"=fuel_ids$SH5, \"Dry-High\"=fuel_ids$SH7, \"Moderate-Low\"=fuel_ids$SH6, \"Moderate-Medium\"=fuel_ids$SH3, \"Moderate-High\"=fuel_ids$SH9, \"Moist-Low\"=fuel_ids$SH6, \"Moist-Medium\"=fuel_ids$SH3, \"Moist-High\"=fuel_ids$SH9),\n  \n  ...\n```\n\n## Python\n\n``` (.python)\n# Build Lookup table\nlookup = {\n\n    \"BL\": {\"Dry-Low\": fuel_ids[\"TL2\"], \"Dry-Medium\": fuel_ids[\"TL6\"], \"Dry-High\": fuel_ids[\"TL9\"], \"Moderate-Low\": fuel_ids[\"TL2\"], \"Moderate-Medium\": fuel_ids[\"TL6\"], \"Moderate-High\": fuel_ids[\"TL9\"], \"Moist-Low\": fuel_ids[\"TL2\"], \"Moist-Medium\": fuel_ids[\"TL6\"], \"Moist-High\": fuel_ids[\"TL9\"]},\n\n    \"CF\": {\"Dry-Low\": fuel_ids[\"TL1\"], \"Dry-Medium\": fuel_ids[\"TL3\"], \"Dry-High\": fuel_ids[\"TL5\"], \"Moderate-Low\": fuel_ids[\"TL1\"], \"Moderate-Medium\": fuel_ids[\"TL3\"], \"Moderate-High\": fuel_ids[\"TL5\"], \"Moist-Low\": fuel_ids[\"TL1\"], \"Moist-Medium\": fuel_ids[\"TL3\"], \"Moist-High\": fuel_ids[\"TL5\"]},\n\n    \"SH\": {\"Dry-Low\": fuel_ids[\"SH2\"], \"Dry-Medium\": fuel_ids[\"SH5\"], \"Dry-High\": fuel_ids[\"SH7\"], \"Moderate-Low\": fuel_ids[\"SH6\"], \"Moderate-Medium\": fuel_ids[\"SH3\"], \"Moderate-High\": fuel_ids[\"SH9\"], \"Moist-Low\": fuel_ids[\"SH6\"], \"Moist-Medium\": fuel_ids[\"SH3\"], \"Moist-High\": fuel_ids[\"SH9\"]},\n    \n    ...\n```\n:::\n\n# 3) Graduate Coursework Project - City Suitability Mapping\n\nThis interactive map allows users to locate the best places to live or invest in Metro Vancouver. You can easily adjust 16 different lifestyle and environmental factors, such as distance to CBD, rent costs, school proximity, and air quality, based on your personal priorities. By moving the sliders, you can generate a personalized Suitability Index that instantly recolors the map to highlight top-performing neighborhoods. Meanwhile, you may indicate your preference regarding certain contentious factors—those which have always been subject to differing opinions. The final result is a ranked list of the top 10 areas that most closely match your ideal balance of benefits and costs.\n\n```{=html}\n<iframe\n  src=\"https://kelvvin55.shinyapps.io/Van_Map/\"\n  width=\"100%\"\n  height=\"700\"\n  style=\"border:0;\">\n</iframe>\n```\n","srcMarkdownNoYaml":"\n\n# 1) Community Project - Disaster Response Mapping\n\nThe aim of this project is to create an interactive map that is readily operable and accessible for Mudge Island residents and volunteers, particularly non-GIS users, in both online and offline circumstances. I set up a free QField account that people can use to update and review the map on their computers or phones anytime, anywhere. Map users can click to access the information they need, such as the precise location of water caches and evacuation points by boat or helicopter. This interactive map has proven invaluable in wildfire response decision-making and enhancing familiarity with the island's environment. The map below is just a demo to show the map's potential.\n\n```{r DRM-leaflet, include = FALSE}\nlibrary(terra)\nlibrary(raster)  # for Leaflet compatibility\nlibrary(leaflet)\n\n## --- Map view defaults -------------------------------------------------------\nmudge_lng <- -123.7910\nmudge_lat <-  49.1290\nzoom_lvl  <- 14\n\n## --- Load rasters ------------------------------------------------------------\nhill   <- rast(\"Maps_Kelvin/Hillshade.tif\")\nslope  <- rast(\"Maps_Kelvin/Slope.tif\")\naspect <- rast(\"Maps_Kelvin/Aspect.tif\")\n\n## --- Load vectors ------------------------------------------------------------\nparcel  <- vect(\"Maps_Kelvin/Parcel.gpkg\")  # use the fixed GeoPackage\nroads   <- vect(\"Maps_Kelvin/Roads.gpkg\")\nwater   <- vect(\"Maps_Kelvin/WaterStorage.gpkg\")\naccess  <- vect(\"Maps_Kelvin/AccessPoints.gpkg\")\naddress <- vect(\"Maps_Kelvin/AddressPoints.gpkg\")\n\n## --- Reproject everything to lat-long (WGS84) --------------------------------\ntarget_crs <- \"EPSG:4326\"\n\nhill    <- project(hill,    target_crs)\nslope   <- project(slope,   target_crs)\naspect  <- project(aspect,  target_crs)\n\nparcel  <- project(parcel,  target_crs)\nroads   <- project(roads,   target_crs)\nwater   <- project(water,   target_crs)\naccess  <- project(access,  target_crs)\naddress <- project(address, target_crs)\n\n## --- Hillshade reclassification ---------------------------------------------\nhill <- classify(hill, matrix(c(\n   1,  85, 1,\n  85, 170, 2,\n 170, 255, 3\n), ncol = 3, byrow = TRUE))\n\nlevels(hill) <- data.frame(\n  value = 1:3,\n  label = c(\"Low illumination\", \"Medium illumination\", \"High illumination\")\n)\n\n## --- Slope reclassification --------------------------------------------------\nslope <- classify(slope, matrix(c(\n   0,   5, 1,\n   5,  15, 2,\n  15,  30, 3,\n  30,  60, 4,\n  60, Inf, 5\n), ncol = 3, byrow = TRUE))\n\nlevels(slope) <- data.frame(\n  value = 1:5,\n  label = c(\"Flat\", \"Gentle\", \"Moderate\", \"Steep\", \"Very Steep\")\n)\n\n## --- Aspect reclassification -------------------------------------------------\naspect <- classify(aspect, matrix(c(\n   0,  45, 1,\n  45,  90, 2,\n  90, 135, 3,\n 135, 180, 4,\n 180, 225, 5,\n 225, 270, 6,\n 270, 315, 7,\n 315, 360, 1\n), ncol = 3, byrow = TRUE), include.lowest = TRUE)\n\nlevels(aspect) <- data.frame(\n  value = 1:7,\n  label = c(\n    \"North\", \"Northeast\", \"East\", \"Southeast\",\n    \"South\", \"Southwest\", \"West\"\n  )\n)\n\n## --- Color palettes ----------------------------------------------------------\nhill_cols   <- c(\"#2b2b2b\", \"#7f7f7f\", \"#d9d9d9\")\nslope_cols  <- c(\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\")\naspect_cols <- c(\"#2b004f\",\"#3b2b8f\",\"#2f5fb3\",\"#2fa4a9\",\n                 \"#33c27d\",\"#7cd250\",\"#c7e75b\")\n\n## --- Convert rasters to 'raster' objects for Leaflet ------------------------\nhill_raster   <- raster(hill)\nslope_raster  <- raster(slope)\naspect_raster <- raster(aspect)\n\n## --- Create Leaflet map ------------------------------------------------------\nm <- leaflet(options = leafletOptions(preferCanvas = TRUE)) %>%\n  \n  addProviderTiles(\"Esri.WorldImagery\", group = \"Basemap\") %>%\n  \n  ## --- Raster layers ---\n  addRasterImage(hill_raster, colors = hill_cols, opacity = 0.45, group = \"Hillshade\") %>%\n  addRasterImage(slope_raster, colors = slope_cols, opacity = 0.6, group = \"Slope\") %>%\n  addRasterImage(aspect_raster, colors = aspect_cols, opacity = 0.6, group = \"Aspect\") %>%\n  \n  ## --- Vector layers ---\n  addPolygons(\n    data = parcel,\n    fill = FALSE,\n    color = \"white\",\n    weight = 1,\n    popup = ~paste0(\n      \"<b>PID:</b> \", PID_FORMATTED, \"<br>\",\n      \"<b>Parcel Name:</b> \", PARCEL_NAME, \"<br>\",\n      \"<b>Municipality:</b> \", MUNICIPALITY\n    ),\n    group = \"Parcels\"\n  ) %>%\n  \n  addPolylines(\n    data = roads,\n    color = \"yellow\",\n    weight = 2,\n    popup = ~paste0(\n      \"<b>Road:</b> \", ROAD_NAME_FULL, \"<br>\",\n      \"<b>Class:</b> \", ROAD_CLASS\n    ),\n    group = \"Roads\"\n  ) %>%\n  \n  addCircleMarkers(\n    data = water,\n    radius = 6,\n    color = \"cyan\",\n    fillOpacity = 0.9,\n    popup = ~paste0(\n      \"<b>Name:</b> \", Name, \"<br>\",\n      \"<b>Description:</b> \", description\n    ),\n    group = \"Water Storage\"\n  ) %>%\n  \n  addCircleMarkers(\n    data = access,\n    radius = 5,\n    color = \"orange\",\n    popup = ~paste0(\n      \"<b>Access Type:</b> \", AccessType, \"<br>\",\n      \"<b>Location:</b> \", Location\n    ),\n    group = \"Access Points\"\n  ) %>%\n  \n  addCircleMarkers(\n    data = address,\n    radius = 4,\n    color = \"blue\",\n    popup = ~paste0(\n      \"<b>Address:</b> \", ADDRESS, \"<br>\",\n      \"<b>Road:</b> \", ROAD\n    ),\n    group = \"Address Points\"\n  ) %>%\n  \n  ## --- Layer control ---\n  addLayersControl(\n    overlayGroups = c(\n      \"Hillshade\", \"Slope\", \"Aspect\",\n      \"Parcels\", \"Roads\", \"Water Storage\",\n      \"Access Points\", \"Address Points\"\n    ),\n    options = layersControlOptions(collapsed = FALSE)\n  ) %>%\n  \n  ## --- Hide raster layers by default ---\n  hideGroup(c(\"Hillshade\", \"Slope\", \"Aspect\")) %>%\n  \n  addScaleBar(position = \"bottomleft\") %>%\n  \n  ## --- Zoom to Mudge Island coordinates ---\n  setView(lng = mudge_lng, lat = mudge_lat, zoom = zoom_lvl)\n```\n\n```{r DRM-map, echo=FALSE}\nm\n```\n\n# 1) Capstone Project - Fuel type Mapping\n\n## Preliminary Fuel Type Map\n\nIn this project, I used a 15-band composite derived from 12 Sentinel-2 bands and 3 vegetation indices (NDVI, EVI, and NDWI) as a predictor and integrated four reference land cover maps (CCRS, CFS, VRI, and AAFC) into a high-confidence ground-truth map, where each class is agreed upon by at least three out of four sources. The one-directional convolutional neural network (1D-CNN) identifies each pixel by looking at its unique “color signature” across 15 layers of light and calculating a percentage score for each category; it then assigns the pixel to the class that gets the highest percentage, representing its best and most confident guess.\n\n```{r PFTM-leaflet, include = FALSE}\n## --- Fix PROJ path in-session (no system changes) ----------------------------\n## Run these BEFORE loading spatial packages (or at the top of your Quarto)\nSys.unsetenv(\"PROJ_LIB\"); Sys.unsetenv(\"PROJ_DATA\"); Sys.unsetenv(\"GDAL_DATA\")\n\n## Point to a modern PROJ install you actually have (pick ONE you have installed):\nSys.setenv(PROJ_LIB = \"C:/Program Files/QGIS 3.34.15/share/proj\")\n# Sys.setenv(PROJ_LIB = \"C:/OSGeo4W/share/proj\")  # if you use OSGeo4W\n\n# (Optional) some builds also expect GDAL_DATA:\nif (dir.exists(\"C:/Program Files/QGIS 3.34.15/share/gdal\")) {\n  Sys.setenv(GDAL_DATA = \"C:/Program Files/QGIS 3.34.15/share/gdal\")\n}\n\n## --- Libraries ---------------------------------------------------------------\nlibrary(terra)\nlibrary(leaflet)\n\n## --- Load raster -------------------------------------------------------------\nr_path <- \"Maps_Kelvin/Preliminary_FTM.tif\"\nstopifnot(file.exists(r_path))\n\nPre_FTM_raw <- rast(r_path)\n\n## --- Ensure the raster has a real CRS (critical) -----------------------------\n## If the file lacks a CRS tag, set the TRUE CRS of the data here.\n## (Example uses BC Albers; change if your data is something else.)\nif (is.na(crs(Pre_FTM_raw)) || crs(Pre_FTM_raw) == \"\") {\n  crs(Pre_FTM_raw) <- \"EPSG:3005\"  # <-- CHANGE to your raster’s actual CRS if different\n}\n\n## --- Build palette / legend domain -------------------------------------------\nvals <- unique(values(Pre_FTM_raw))\nvals <- vals[!is.na(vals)]\n\nfuel_labels <- c(\"Broadleaf\",\"Conifer\",\"Shrub\",\"Grass\",\"Bare Soil\",\"Urban\",\"Water\")\nfuel_colors <- c(\"#00FF00\",\"#008000\",\"#FF0000\",\"#E69F00\",\"#808080\",\"#FFFFFF\",\"#0000FF\")\n\nif (length(fuel_colors) < length(vals) || length(fuel_labels) < length(vals)) {\n  warning(\"You have more classes in the raster than labels/colors supplied. \",\n          \"Some classes may be unlabeled/uncolored.\")\n}\n\npal <- colorFactor(\n  palette  = fuel_colors,\n  domain   = vals,\n  na.color = \"transparent\"\n)\n\n## --- Map view defaults -------------------------------------------------------\nmudge_lng <- -123.7910\nmudge_lat <-  49.1290\nzoom_lvl  <- 14\n\n## --- Leaflet map -------------------------------------------------------------\nLea_01 <- leaflet() %>%\n  addProviderTiles(\"Esri.WorldImagery\") %>%\n  setView(lng = mudge_lng, lat = mudge_lat, zoom = zoom_lvl) %>%\n  addRasterImage(\n    Pre_FTM_raw,\n    colors  = pal,\n    opacity = 0.8,\n    project = TRUE,        # leaflet/terra reprojects to EPSG:3857\n    method  = \"ngb\",       # categorical classes\n    maxBytes = 16 * 1024^2\n  ) %>%\n  addLegend(\n    pal    = pal,\n    values = vals,\n    title  = \"Fuel Type\",\n    labFormat = labelFormat(transform = function(x) {\n      idx <- suppressWarnings(as.integer(x))\n      out <- rep(NA_character_, length(idx))\n      ok  <- !is.na(idx) & idx >= 1 & idx <= length(fuel_labels)\n      out[ok] <- fuel_labels[idx[ok]]\n      out\n    })\n  ) %>%\n  addScaleBar(position = \"bottomleft\")\n```\n\n```{r PFT-map, echo=FALSE}\nLea_01\n```\n\n## Code Snippets\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n``` (.r)\nlibrary(terra)\n\n# Compute per-pixel agreement count (1–4)\nagree_count <- app(ref_stack, fun = function(x) {\n  if (all(is.na(x))) return(NA)\n  tab <- table(x)\n  return(max(tab))\n})\n\n# Compute modal (most common) class value\nagree_modal <- app(ref_stack, fun = function(x) {\n  if (all(is.na(x))) return(NA)\n  tab <- table(x)\n  return(as.numeric(names(which.max(tab))))\n})\n```\n\n## Python\n\n``` (.python)\nimport numpy as np\n\ndef compute_agreement(ref_stack):\n    bands, H, W = ref_stack.shape\n    flat = ref_stack.reshape(bands, -1)\n\n    agree_count = np.full(flat.shape[1], np.nan)\n    agree_modal = np.full(flat.shape[1], np.nan)\n\n    for i in range(flat.shape[1]):\n        x = flat[:, i]\n        x = x[~np.isnan(x)]\n        if x.size == 0:\n            continue\n\n        vals, cnts = np.unique(x, return_counts=True)\n        j = cnts.argmax()\n        \n        # Compute per-pixel agreement count (1–4)\n        agree_count[i] = cnts[j]\n        \n        # Compute modal (most common) class value\n        agree_modal[i] = vals[j]\n\n    return agree_count.reshape(H, W), agree_modal.reshape(H, W)\n```\n:::\n\n## Biophysical Inputs: Biomass & Dryness indices\n\nI also integrated two biophysical features into my preliminary fuel type map. The above-ground tree biomass map was reclassified into three classes: low (0–150 tons/ha), medium (150–350 tons/ha), and high (\\> 350 tons/ha) biomass. Sentinel-2 spectral bands (B03, BO8), topographic data (DEM, Slope), and PRISM climatic variables (MAT, MAP) were utilized to derive the dryness index and then reclassified into three fuel moisture classes: moist (0.00–0.30), moderate (0.30–0.60), and dry (0.60–1.00). Subsequently, I combined these two maps into a 9-class Biomass-Dryness (BD) Map.\n\n```{r BDM-leaflet, include = FALSE}\nlibrary(terra)\nlibrary(leaflet)\n\n## --- Load raster -------------------------------------------------------------\nBDM_raw <- rast(\"Maps_Kelvin/Biomass_Dryness_Map.tif\")\n\n## --- Ensure the raster has its true CRS (critical) ---------------------------\n## Replace EPSG:3005 with the actual CRS if different.\nif (is.na(crs(BDM_raw)) || crs(BDM_raw) == \"\") {\n  crs(BDM_raw) <- \"EPSG:3005\"   # <-- CHANGE if your data uses another CRS\n}\n\n## --- Prepare classes / palette / labels -------------------------------------\nvals_01 <- unique(values(BDM_raw))\nvals_01 <- vals_01[!is.na(vals_01)]\n\ndryness_labels <- c(\n  \"Moderate-Low\",\n  \"Moderate-Medium\",\n  \"Moderate-High\",\n  \"Dry-Low\",\n  \"Dry-Medium\",\n  \"Dry-High\"\n)\n\ndryness_colors <- c(\n  \"#00FF00\",\n  \"#008000\",\n  \"#FF0000\",\n  \"#FFFF00\",\n  \"#7FFF00\",\n  \"#D2691E\"\n)\n\ncodes <- sort(unique(vals_01))\n\nif (length(codes) == 9 && all(codes %in% 1:9)) {\n  pal_01 <- colorFactor(\n    palette  = dryness_colors,\n    domain   = codes,\n    na.color = \"transparent\"\n  )\n  label_fn <- function(x) {\n    idx <- suppressWarnings(as.integer(x))\n    lab <- rep(NA_character_, length(idx))\n    ok  <- !is.na(idx) & idx >= 1 & idx <= length(dryness_labels)\n    lab[ok] <- dryness_labels[idx[ok]]\n    lab\n  }\n} else {\n  names(dryness_colors) <- as.character(codes)\n  names(dryness_labels) <- as.character(codes)\n  pal_01 <- colorFactor(\n    palette  = unname(dryness_colors[as.character(codes)]),\n    domain   = codes,\n    na.color = \"transparent\"\n  )\n  label_fn <- function(x) dryness_labels[as.character(x)]\n}\n\n## --- Map camera --------------------------------------------------------------\nmudge_lng <- -123.7910\nmudge_lat <-  49.1290\nzoom_lvl  <- 14\n\n## --- Leaflet map (let Leaflet/terra project to EPSG:3857) --------------------\nLea_02 <- leaflet() %>%\n  addProviderTiles(\"Esri.WorldImagery\") %>%\n  setView(lng = mudge_lng, lat = mudge_lat, zoom = zoom_lvl) %>%\n  addRasterImage(\n    BDM_raw,\n    colors   = pal_01,\n    opacity  = 0.8,\n    project  = TRUE,     # <- reproject to Web Mercator on the fly\n    method   = \"ngb\",    # <- categorical data\n    maxBytes = 16 * 1024^2\n  ) %>%\n  addLegend(\n    pal      = pal_01,\n    values   = codes,\n    title    = \"Biomass‑Dryness\",\n    labFormat = labelFormat(transform = label_fn)\n  ) %>%\n  addScaleBar(position = \"bottomleft\")\n```\n\n```{r BD-map, echo=FALSE}\nLea_02\n```\n\n## Code Snippets\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n``` (.r)\n# Combine into Dryness Index (weights sum ≈ 1)\ndryness <- (0.30 * mat_n) +\n  (0.25 * slope_n) +\n  (0.20 * map_n) +\n  (0.15 * ndwi_n) +\n  (0.10 * dem_n)\n\n# Normalize to 0–1\ndryness <- normalize(dryness)\n```\n\n## Python\n\n``` (.python)\nimport numpy as np\n\n# Combine into Dryness Index (same weights as R)\ndryness = (\n    0.30 * mat_n +\n    0.25 * slope_n +\n    0.20 * map_n +\n    0.15 * ndwi_n +\n    0.10 * dem_n\n)\n\n# Min–max normalization (terra::normalize equivalent)\nmin_val = np.nanmin(dryness)\nmax_val = np.nanmax(dryness)\n\ndryness = (dryness - min_val) / (max_val - min_val)\n```\n:::\n\n## Refined Fuel Model Map\n\nThe final fuel type map was generated by first filtering out unburnable areas, such as water and urban surfaces. Next, I employed CNN-based unmixing to identify specific vegetation patterns (e.g., Conifer (CF) & Broadleaf (BL)) and \"mixed\" classes (e.g., Grass-Shrub (GS) & Timber-Shrub-Grass (TSG)). This vegetation data was combined with a BD9 map, which classifies the landscape into nine categories based on biomass levels and dryness. Eventually, the decision matrix cross-references these two layers through a lookup table to assign each pixel a standardized fire behavior code from the Scott and Burgan (2005) system.\n\n```{r FFTM-leaflet, include = FALSE}\nlibrary(terra)\nlibrary(leaflet)\nlibrary(htmltools)\n\n## --- Load raster -------------------------------------------------------------\nSB_raw <- rast(\"Maps_Kelvin/SB_FMI.tif\")\n\n## --- Ensure the raster has a true CRS (critical) -----------------------------\n## Replace EPSG:3005 if your data uses a different CRS.\nif (is.na(crs(SB_raw)) || crs(SB_raw) == \"\") {\n  crs(SB_raw) <- \"EPSG:3005\"   # <-- CHANGE if your data uses another CRS\n}\n\n## --- Domain / codes ----------------------------------------------------------\nvals_02  <- as.vector(values(SB_raw))\nvals_02  <- vals_02[!is.na(vals_02)]\ncodes_01 <- sort(unique(vals_02))\n\n## --- Labels and colors -------------------------------------------------------\nfinal_fuel_labels <- c(\n  \"TL1\",\"TL2\",\"TL3\",\"TL5\",\"TL6\",\"TL9\",\n  \"SH2\",\"SH3\",\"SH4\",\"SH5\",\"SH6\",\"SH7\",\"SH8\",\"SH9\",\n  \"GR2\",\"GR4\",\"GR5\",\"GR6\",\"GR7\",\"GR9\",\n  \"GS1\",\"GS2\",\"GS3\",\"GS4\",\n  \"TU1\",\"TU2\",\"TU3\",\"TU5\"\n)\n\nfinal_fuel_colors <- c(\n  \"#D6C69A\",\"#D6B27A\",\"#4BE28C\",\"#13A7E6\",\"#E63946\",\"#2C67E4\",\n  \"#08B9E6\",\"#D423E6\",\"#80E3E6\",\"#A642E6\",\"#B1E68A\",\"#F0C000\",\n  \"#C16727\",\"#3C67D6\",\"#1F47D6\",\"#5BD6E6\",\"#23A7D6\",\"#E63E4A\",\n  \"#4CE64C\",\"#D63F40\",\"#D6C666\",\"#A6E6A6\",\"#A7E6C3\",\"#D6C09A\",\n  \"#C32ECF\",\"#00A830\",\"#4EDC5B\",\"#52A7D6\"\n)\n\n## If your raster values are **codes** that correspond 1:1 with the label/color order,\n## we can build a named palette to keep mapping stable regardless of which codes appear.\n## For example, if values are 1..28 and match the above order:\n##   1->TL1, 2->TL2, ..., 28->TU5\n## If your codes are *not* 1..28, adjust 'all_codes' accordingly.\nall_codes <- seq_along(final_fuel_labels)       # 1..28 by default\nstopifnot(length(all_codes) == length(final_fuel_labels),\n          length(final_fuel_labels) == length(final_fuel_colors))\n\n# Build named vectors for robust mapping\nnames(final_fuel_labels) <- as.character(all_codes)\nnames(final_fuel_colors) <- as.character(all_codes)\n\n# Subset to the codes present in the raster, preserving names\npresent <- intersect(as.character(all_codes), as.character(codes_01))\npal_02 <- colorFactor(\n  palette  = unname(final_fuel_colors[present]),\n  domain   = as.numeric(present),\n  na.color = \"transparent\"\n)\n\n## --- HTML legend (unchanged) -------------------------------------------------\nlegend_html_multi <- function(title, labels, colors, ncol = 3, font_size = 10) {\n  stopifnot(length(labels) == length(colors))\n  k <- length(labels)\n  # Split indices into ncol roughly-equal groups\n  cuts   <- ceiling(seq(0, k, length.out = ncol + 1))\n  splits <- lapply(seq_len(ncol), function(j) (cuts[j] + 1):cuts[j + 1])\n\n  make_col <- function(idx) {\n    idx <- idx[!is.na(idx)]\n    tags$ul(\n      style = \"list-style:none; padding:0 10px 0 0; margin:0;\",\n      lapply(idx, function(i) {\n        tags$li(\n          style = \"display:flex; align-items:center; margin: 2px 0;\",\n          tags$span(style = paste0(\n            \"display:inline-block;width:10px;height:10px;\",\n            \"border:1px solid #555;margin-right:6px;background:\", colors[i], \";\"\n          )),\n          tags$span(labels[i])\n        )\n      })\n    )\n  }\n\n  tags$div(\n    style = paste0(\n      \"background: rgba(255,255,255,0.92); padding:8px 10px; border-radius:4px; \",\n      \"box-shadow: 0 1px 4px rgba(0,0,0,0.3); \",\n      \"font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif; \",\n      \"font-size:\", font_size, \"px; max-height: 280px; overflow-y:auto;\"\n    ),\n    tags$div(style=\"font-weight:600; margin-bottom:6px;\", title),\n    tags$div(style = \"display:flex; flex-direction:row;\", lapply(splits, make_col))\n  )\n}\n\nleg_html <- legend_html_multi(\n  title  = \"Final Fuel Type Map\",\n  labels = final_fuel_labels,\n  colors = final_fuel_colors,\n  ncol   = 3,\n  font_size = 10\n)\n\n## --- Map view ----------------------------------------------------------------\nmudge_lng <- -123.7910\nmudge_lat <-  49.1290\nzoom_lvl  <- 14\n\nLea_03 <- leaflet() %>%\n  addProviderTiles(\"Esri.WorldImagery\") %>%\n  setView(lng = mudge_lng, lat = mudge_lat, zoom = zoom_lvl) %>%\n  addRasterImage(\n    SB_raw,\n    colors   = pal_02,\n    opacity  = 0.8,\n    project  = TRUE,     # <- let Leaflet/terra project to EPSG:3857\n    method   = \"ngb\",    # <- categorical data\n    maxBytes = 16 * 1024^2\n  ) %>%\n  addControl(html = as.character(leg_html), position = \"topright\") %>%\n  addScaleBar(position = \"bottomleft\")\n```\n\n```{r FFT-map, echo=FALSE}\nLea_03\n```\n\n## Code Snippets\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n``` (.r)\n# Build Lookup table\nlookup <- list(\n  \n  BL = c(\"Dry-Low\"=fuel_ids$TL2, \"Dry-Medium\"=fuel_ids$TL6, \"Dry-High\"=fuel_ids$TL9, \"Moderate-Low\"=fuel_ids$TL2, \"Moderate-Medium\"=fuel_ids$TL6, \"Moderate-High\"=fuel_ids$TL9, \"Moist-Low\"=fuel_ids$TL2, \"Moist-Medium\"=fuel_ids$TL6, \"Moist-High\"=fuel_ids$TL9),\n  \n  CF = c(\"Dry-Low\"=fuel_ids$TL1, \"Dry-Medium\"=fuel_ids$TL3, \"Dry-High\"=fuel_ids$TL5, \"Moderate-Low\"=fuel_ids$TL1, \"Moderate-Medium\"=fuel_ids$TL3, \"Moderate-High\"=fuel_ids$TL5, \"Moist-Low\"=fuel_ids$TL1, \"Moist-Medium\"=fuel_ids$TL3, \"Moist-High\"=fuel_ids$TL5),\n  \n  SH = c(\"Dry-Low\"=fuel_ids$SH2, \"Dry-Medium\"=fuel_ids$SH5, \"Dry-High\"=fuel_ids$SH7, \"Moderate-Low\"=fuel_ids$SH6, \"Moderate-Medium\"=fuel_ids$SH3, \"Moderate-High\"=fuel_ids$SH9, \"Moist-Low\"=fuel_ids$SH6, \"Moist-Medium\"=fuel_ids$SH3, \"Moist-High\"=fuel_ids$SH9),\n  \n  ...\n```\n\n## Python\n\n``` (.python)\n# Build Lookup table\nlookup = {\n\n    \"BL\": {\"Dry-Low\": fuel_ids[\"TL2\"], \"Dry-Medium\": fuel_ids[\"TL6\"], \"Dry-High\": fuel_ids[\"TL9\"], \"Moderate-Low\": fuel_ids[\"TL2\"], \"Moderate-Medium\": fuel_ids[\"TL6\"], \"Moderate-High\": fuel_ids[\"TL9\"], \"Moist-Low\": fuel_ids[\"TL2\"], \"Moist-Medium\": fuel_ids[\"TL6\"], \"Moist-High\": fuel_ids[\"TL9\"]},\n\n    \"CF\": {\"Dry-Low\": fuel_ids[\"TL1\"], \"Dry-Medium\": fuel_ids[\"TL3\"], \"Dry-High\": fuel_ids[\"TL5\"], \"Moderate-Low\": fuel_ids[\"TL1\"], \"Moderate-Medium\": fuel_ids[\"TL3\"], \"Moderate-High\": fuel_ids[\"TL5\"], \"Moist-Low\": fuel_ids[\"TL1\"], \"Moist-Medium\": fuel_ids[\"TL3\"], \"Moist-High\": fuel_ids[\"TL5\"]},\n\n    \"SH\": {\"Dry-Low\": fuel_ids[\"SH2\"], \"Dry-Medium\": fuel_ids[\"SH5\"], \"Dry-High\": fuel_ids[\"SH7\"], \"Moderate-Low\": fuel_ids[\"SH6\"], \"Moderate-Medium\": fuel_ids[\"SH3\"], \"Moderate-High\": fuel_ids[\"SH9\"], \"Moist-Low\": fuel_ids[\"SH6\"], \"Moist-Medium\": fuel_ids[\"SH3\"], \"Moist-High\": fuel_ids[\"SH9\"]},\n    \n    ...\n```\n:::\n\n# 3) Graduate Coursework Project - City Suitability Mapping\n\nThis interactive map allows users to locate the best places to live or invest in Metro Vancouver. You can easily adjust 16 different lifestyle and environmental factors, such as distance to CBD, rent costs, school proximity, and air quality, based on your personal priorities. By moving the sliders, you can generate a personalized Suitability Index that instantly recolors the map to highlight top-performing neighborhoods. Meanwhile, you may indicate your preference regarding certain contentious factors—those which have always been subject to differing opinions. The final result is a ranked list of the top 10 areas that most closely match your ideal balance of benefits and costs.\n\n```{=html}\n<iframe\n  src=\"https://kelvvin55.shinyapps.io/Van_Map/\"\n  width=\"100%\"\n  height=\"700\"\n  style=\"border:0;\">\n</iframe>\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"content.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.27","editor":"visual","theme":"flatly","title":"Content & Deliverables"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}