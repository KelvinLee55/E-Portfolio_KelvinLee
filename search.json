[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kelvin Lee",
    "section": "",
    "text": "My name is Kelvin Lee. I was raised in Hong Kong and moved to Vancouver, British Columbia, in 2025. I hold a bachelor‚Äôs degree in geography from Hong Kong Baptist University and a master‚Äôs degree in geomatics for environmental management from the University of British Columbia. My academic background has equipped me with a solid foundation in environmental systems, spatial analysis, and data-driven decision-making.\nMy professional experience spans environmental education, ecological fieldwork, and geospatial analysis. I supported public outreach and conservation education initiatives, communicating topics such as coral reef and wildlife conservation to diverse audiences. I also contributed to ecological surveys, plantation management, and biodiversity monitoring projects. In these roles, I worked with field data, developed practical guidelines, and applied geospatial tools to support ecosystem restoration efforts.\nMy interest in environmental sustainability is rooted in a long-standing connection with wildlife and plants, shaped through both academic training and hands-on experience. Outside of work, I enjoy camping and trekking, which allow me to engage closely with natural landscapes and connect with like-minded individuals. I am particularly intrigued by the impact of urban green spaces in shaping environmental quality, especially their complex and sometimes contrasting effects on air pollution.\nLooking ahead, I aim to further explore wildfire management challenges associated with the wildland-urban interface in remote islands, using geomatics and spatial analysis to better understand fuel characterization. I am motivated to apply my technical skills, field experience, and passion for nature toward developing practical and innovative solutions for fire-prone remote communities."
  },
  {
    "objectID": "resume.html",
    "href": "resume.html",
    "title": "Resume",
    "section": "",
    "text": "Education\n\nMaster of Geomatics for Environmental Management (MGEM) | University of British Columbia | Vancouver, BC | 2026\nBachelor of Social Sciences in Geography (First Class Honours) | Hong Kong Baptist University | Hong Kong | 2025\nAssociate of Applied Sciences in Geography and Resources Management | Hong Kong Baptist University | Hong Kong | 2023\n\n\n\nProfessional Experience\n\nGraduate Mapping Assistant\nMudge Island Citizen‚Äôs Society (M.I.C.S) | Aug 2025 ‚Äì Apr 2026\n\nI worked with the non-profit organization M.I.C.S., where I developed interactive disaster response maps using QGIS and QField. I worked with GeoTIFF orthophotos, LAS/LAZ LiDAR point clouds, and vector datasets (SHP, GeoJSON, KML), which supported field-based mapping and wildfire response planning.\n\nEcological Survey and Plantation Management Intern\nAgriculture, Fisheries and Conservation Department (AFCD), Hong Kong | Jun 2024 ‚Äì Aug 2024\n\nIn my role as an intern at AFCD, I contributed to tree condition inspections for NGOs, developed a seedling planting guide, and applied geospatial and data management tools, including ArcGIS Pro, to analyze data from Plantation Enrichment Programme (PEP) pilot sites.\n\nEnvironmental Education Intern\nWorld Wide Fund for Nature (WWF), Hong Kong | Jun 2022 ‚Äì Aug 2022\n\nI completed an internship at WWF, during which I communicated topics related to coral reef and tiger conservation through public talks and ecotours, and developed educational materials and standard operating procedures (SOPs). These experiences strengthened my presentation skills, ability to work independently, and resilience in fast-paced settings.\n\nField Investigator\nFood Grace, Hong Kong | Oct 2021 ‚Äì Jan 2022\n\nI was offered employment at Food Grace to interview restaurant managers about food-waste management practices. This includes, but is not limited to, qualitative data collection, environmental reporting, and stakeholder communication. These efforts were translated into the sustainability assessment in different Hong Kong districts.\n\n\nPublications\nMajor Projects:\n\nLee, K. H. (2025). Fuel type mapping frosm Sentinel-2 multispectral imagery using a Convolutional Neural Network (CNN) classification framework: A case study on Mudge Island, British Columbia. [Unpublished research proposal]. University of British Columbia. View document\nLee, K. H. K. (2025). Evaluating the impact of urban parks on air quality enhancement in Hong Kong. [Honours project, Hong Kong Baptist University].\nView document\n\nReports:\n\nLee, K. L. (2025). How can pre-fire above-ground biomass (AGB) structure and burn-severity patterns guide fuel-management strategies in Coastal Douglas-fir (Pseudotsuga menziesii) forest ecosystems? [Unpublished research proposal]. University of British Columbia.\nView document\n\n\n\nAwards & Honors\n\nMr.¬†Yu Shao Shing Memorial Scholarship\n\n\n\nCertifercate\n\nCertificate Of Completion: Integrate Data with the FME Platform"
  },
  {
    "objectID": "publications.html",
    "href": "publications.html",
    "title": "Publications",
    "section": "",
    "text": "Major Projects:\n\nLee, K. H. (2025). Fuel type mapping frosm Sentinel-2 multispectral imagery using a Convolutional Neural Network (CNN) classification framework: A case study on Mudge Island, British Columbia. [Unpublished research proposal]. University of British Columbia. View document\nLee, K. H. K. (2025). Evaluating the impact of urban parks on air quality enhancement in Hong Kong. [Honours project, Hong Kong Baptist University].\nView document\n\nReports:\n\nLee, K. L. (2025). How can pre-fire above-ground biomass (AGB) structure and burn-severity patterns guide fuel-management strategies in Coastal Douglas-fir (Pseudotsuga menziesii) forest ecosystems? [Unpublished research proposal]. University of British Columbia.\nView document"
  },
  {
    "objectID": "content_development.html",
    "href": "content_development.html",
    "title": "Content & Deliverables",
    "section": "",
    "text": "Project Deliverable 1\nThis is a sample page where you can archive project deliverables."
  },
  {
    "objectID": "content.html",
    "href": "content.html",
    "title": "Content & Deliverables",
    "section": "",
    "text": "The aim of this project is to create an interactive map that is readily operable and accessible for Mudge Island residents and volunteers, particularly non-GIS users, in both online and offline circumstances. I set up a free QField account that people can use to update and review the map on their computers or phones anytime, anywhere. Map users can click to access the information they need, such as the precise location of water caches and evacuation points by boat or helicopter. This interactive map has proven invaluable in wildfire response decision-making and enhancing familiarity with the island‚Äôs environment. The map below is just a demo to show the map‚Äôs potential."
  },
  {
    "objectID": "content.html#leaflet",
    "href": "content.html#leaflet",
    "title": "Content & Deliverables",
    "section": "",
    "text": "Sample leaflet - for detailed leaflet instructions, visit the FCOR 599 workshop archive page here."
  },
  {
    "objectID": "content.html#code-snippets",
    "href": "content.html#code-snippets",
    "title": "Content & Deliverables",
    "section": "Code Snippets",
    "text": "Code Snippets\n\nRPython\n\n\nlibrary(terra)\n\n# Compute per-pixel agreement count (1‚Äì4)\nagree_count &lt;- app(ref_stack, fun = function(x) {\n  if (all(is.na(x))) return(NA)\n  tab &lt;- table(x)\n  return(max(tab))\n})\n\n# Compute modal (most common) class value\nagree_modal &lt;- app(ref_stack, fun = function(x) {\n  if (all(is.na(x))) return(NA)\n  tab &lt;- table(x)\n  return(as.numeric(names(which.max(tab))))\n})\n\n\nimport numpy as np\n\ndef compute_agreement(ref_stack):\n    bands, H, W = ref_stack.shape\n    flat = ref_stack.reshape(bands, -1)\n\n    agree_count = np.full(flat.shape[1], np.nan)\n    agree_modal = np.full(flat.shape[1], np.nan)\n\n    for i in range(flat.shape[1]):\n        x = flat[:, i]\n        x = x[~np.isnan(x)]\n        if x.size == 0:\n            continue\n\n        vals, cnts = np.unique(x, return_counts=True)\n        j = cnts.argmax()\n        \n        # Compute per-pixel agreement count (1‚Äì4)\n        agree_count[i] = cnts[j]\n        \n        # Compute modal (most common) class value\n        agree_modal[i] = vals[j]\n\n    return agree_count.reshape(H, W), agree_modal.reshape(H, W)"
  },
  {
    "objectID": "content.html#external-links",
    "href": "content.html#external-links",
    "title": "Content & Deliverables",
    "section": "",
    "text": "You can also provide a frame linking to external websites. For example, here is a Google Earth Engine application I developed - which I embedded in this webpage using the code below:\n\n\n&lt;iframe width=\"900\" height=\"700\"\nsrc=\"https://ee-melserramon.projects.earthengine.app/view/thermal-analysis-tool\"&gt;\n&lt;/iframe&gt;\n\nThe full-screen GEE application is available here in case you‚Äôre interested.\n(To use the GEE tool, navigate to any city you‚Äôd like, hit apply filters, and click anywhere on the map to retrieve a time-series of Landsat surface temperature observations for that point. Areas where the maximum temp exceeded 35 degrees Celsius in your date-range are highlighted in red.)"
  },
  {
    "objectID": "index.html#about-me",
    "href": "index.html#about-me",
    "title": "Kelvin Lee",
    "section": "",
    "text": "My name is Kelvin Lee. I was raised in Hong Kong and moved to Vancouver, British Columbia, in 2025. I hold a bachelor‚Äôs degree in geography from Hong Kong Baptist University and a master‚Äôs degree in geomatics for environmental management from the University of British Columbia. My academic background has equipped me with a solid foundation in environmental systems, spatial analysis, and data-driven decision-making.\nMy professional experience spans environmental education, ecological fieldwork, and geospatial analysis. I supported public outreach and conservation education initiatives, communicating topics such as coral reef and wildlife conservation to diverse audiences. I also contributed to ecological surveys, plantation management, and biodiversity monitoring projects. In these roles, I worked with field data, developed practical guidelines, and applied geospatial tools to support ecosystem restoration efforts.\nMy interest in environmental sustainability is rooted in a long-standing connection with wildlife and plants, shaped through both academic training and hands-on experience. Outside of work, I enjoy camping and trekking, which allow me to engage closely with natural landscapes and connect with like-minded individuals. I am particularly intrigued by the impact of urban green spaces in shaping environmental quality, especially their complex and sometimes contrasting effects on air pollution.\nLooking ahead, I aim to further explore wildfire management challenges associated with the wildland-urban interface in remote islands, using geomatics and spatial analysis to better understand fuel characterization. I am motivated to apply my technical skills, field experience, and passion for nature toward developing practical and innovative solutions for fire-prone remote communities."
  },
  {
    "objectID": "Project.html",
    "href": "Project.html",
    "title": "Project",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "Project.html#quarto",
    "href": "Project.html#quarto",
    "title": "Project",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "Project.html#running-code",
    "href": "Project.html#running-code",
    "title": "Project",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "content.html#preliminary-fuel-type-map",
    "href": "content.html#preliminary-fuel-type-map",
    "title": "Content & Deliverables",
    "section": "Preliminary Fuel Type Map",
    "text": "Preliminary Fuel Type Map\nIn this project, I used a 15-band composite derived from 12 Sentinel-2 bands and 3 vegetation indices (NDVI, EVI, and NDWI) as a predictor and integrated four reference land cover maps (CCRS, CFS, VRI, and AAFC) into a high-confidence ground-truth map, where each class is agreed upon by at least three out of four sources. The one-directional convolutional neural network (1D-CNN) identifies each pixel by looking at its unique ‚Äúcolor signature‚Äù across 15 layers of light and calculating a percentage score for each category; it then assigns the pixel to the class that gets the highest percentage, representing its best and most confident guess."
  },
  {
    "objectID": "content.html#biophysical-inputs-biomass-dryness-indices",
    "href": "content.html#biophysical-inputs-biomass-dryness-indices",
    "title": "Content & Deliverables",
    "section": "Biophysical Inputs: Biomass & Dryness indices",
    "text": "Biophysical Inputs: Biomass & Dryness indices\nI also integrated two biophysical features into my preliminary fuel type map. The above-ground tree biomass map was reclassified into three classes: low (0‚Äì150 tons/ha), medium (150‚Äì350 tons/ha), and high (&gt; 350 tons/ha) biomass. Sentinel-2 spectral bands (B03, BO8), topographic data (DEM, Slope), and PRISM climatic variables (MAT, MAP) were utilized to derive the dryness index and then reclassified into three fuel moisture classes: moist (0.00‚Äì0.30), moderate (0.30‚Äì0.60), and dry (0.60‚Äì1.00). Subsequently, I combined these two maps into a 9-class Biomass-Dryness (BD) Map."
  },
  {
    "objectID": "content.html#code-snippets-1",
    "href": "content.html#code-snippets-1",
    "title": "Content & Deliverables",
    "section": "Code Snippets",
    "text": "Code Snippets\n\nRPython\n\n\n# Combine into Dryness Index (weights sum ‚âà 1)\ndryness &lt;- (0.30 * mat_n) +\n  (0.25 * slope_n) +\n  (0.20 * map_n) +\n  (0.15 * ndwi_n) +\n  (0.10 * dem_n)\n\n# Normalize to 0‚Äì1\ndryness &lt;- normalize(dryness)\n\n\nimport numpy as np\n\n# Combine into Dryness Index (same weights as R)\ndryness = (\n    0.30 * mat_n +\n    0.25 * slope_n +\n    0.20 * map_n +\n    0.15 * ndwi_n +\n    0.10 * dem_n\n)\n\n# Min‚Äìmax normalization (terra::normalize equivalent)\nmin_val = np.nanmin(dryness)\nmax_val = np.nanmax(dryness)\n\ndryness = (dryness - min_val) / (max_val - min_val)"
  },
  {
    "objectID": "content.html#refined-fuel-model-map",
    "href": "content.html#refined-fuel-model-map",
    "title": "Content & Deliverables",
    "section": "Refined Fuel Model Map",
    "text": "Refined Fuel Model Map\nThe final fuel type map was generated by first filtering out unburnable areas, such as water and urban surfaces. Next, I employed CNN-based unmixing to identify specific vegetation patterns (e.g., Conifer (CF) & Broadleaf (BL)) and ‚Äúmixed‚Äù classes (e.g., Grass-Shrub (GS) & Timber-Shrub-Grass (TSG)). This vegetation data was combined with a BD9 map, which classifies the landscape into nine categories based on biomass levels and dryness. Eventually, the decision matrix cross-references these two layers through a lookup table to assign each pixel a standardized fire behavior code from the Scott and Burgan (2005) system."
  },
  {
    "objectID": "content.html#code-snippets-2",
    "href": "content.html#code-snippets-2",
    "title": "Content & Deliverables",
    "section": "Code Snippets",
    "text": "Code Snippets\n\nRPython\n\n\n# Build Lookup table\nlookup &lt;- list(\n  \n  BL = c(\"Dry-Low\"=fuel_ids$TL2, \"Dry-Medium\"=fuel_ids$TL6, \"Dry-High\"=fuel_ids$TL9, \"Moderate-Low\"=fuel_ids$TL2, \"Moderate-Medium\"=fuel_ids$TL6, \"Moderate-High\"=fuel_ids$TL9, \"Moist-Low\"=fuel_ids$TL2, \"Moist-Medium\"=fuel_ids$TL6, \"Moist-High\"=fuel_ids$TL9),\n  \n  CF = c(\"Dry-Low\"=fuel_ids$TL1, \"Dry-Medium\"=fuel_ids$TL3, \"Dry-High\"=fuel_ids$TL5, \"Moderate-Low\"=fuel_ids$TL1, \"Moderate-Medium\"=fuel_ids$TL3, \"Moderate-High\"=fuel_ids$TL5, \"Moist-Low\"=fuel_ids$TL1, \"Moist-Medium\"=fuel_ids$TL3, \"Moist-High\"=fuel_ids$TL5),\n  \n  SH = c(\"Dry-Low\"=fuel_ids$SH2, \"Dry-Medium\"=fuel_ids$SH5, \"Dry-High\"=fuel_ids$SH7, \"Moderate-Low\"=fuel_ids$SH6, \"Moderate-Medium\"=fuel_ids$SH3, \"Moderate-High\"=fuel_ids$SH9, \"Moist-Low\"=fuel_ids$SH6, \"Moist-Medium\"=fuel_ids$SH3, \"Moist-High\"=fuel_ids$SH9),\n  \n  ...\n\n\n# Build Lookup table\nlookup = {\n\n    \"BL\": {\"Dry-Low\": fuel_ids[\"TL2\"], \"Dry-Medium\": fuel_ids[\"TL6\"], \"Dry-High\": fuel_ids[\"TL9\"], \"Moderate-Low\": fuel_ids[\"TL2\"], \"Moderate-Medium\": fuel_ids[\"TL6\"], \"Moderate-High\": fuel_ids[\"TL9\"], \"Moist-Low\": fuel_ids[\"TL2\"], \"Moist-Medium\": fuel_ids[\"TL6\"], \"Moist-High\": fuel_ids[\"TL9\"]},\n\n    \"CF\": {\"Dry-Low\": fuel_ids[\"TL1\"], \"Dry-Medium\": fuel_ids[\"TL3\"], \"Dry-High\": fuel_ids[\"TL5\"], \"Moderate-Low\": fuel_ids[\"TL1\"], \"Moderate-Medium\": fuel_ids[\"TL3\"], \"Moderate-High\": fuel_ids[\"TL5\"], \"Moist-Low\": fuel_ids[\"TL1\"], \"Moist-Medium\": fuel_ids[\"TL3\"], \"Moist-High\": fuel_ids[\"TL5\"]},\n\n    \"SH\": {\"Dry-Low\": fuel_ids[\"SH2\"], \"Dry-Medium\": fuel_ids[\"SH5\"], \"Dry-High\": fuel_ids[\"SH7\"], \"Moderate-Low\": fuel_ids[\"SH6\"], \"Moderate-Medium\": fuel_ids[\"SH3\"], \"Moderate-High\": fuel_ids[\"SH9\"], \"Moist-Low\": fuel_ids[\"SH6\"], \"Moist-Medium\": fuel_ids[\"SH3\"], \"Moist-High\": fuel_ids[\"SH9\"]},\n    \n    ..."
  },
  {
    "objectID": "Maps_Kelvin/Map_Data/FinalMap.html",
    "href": "Maps_Kelvin/Map_Data/FinalMap.html",
    "title": "Set up + Load Data ##",
    "section": "",
    "text": "# try run this if the following import doesn't work ! otherwise ask CharGPT! \n# commenting out the package you already have saves some time maybe......\n!pip install numpy\n!pip install pandas\n!pip install geopandas\n!pip install branca\n!pip install folium\n!pip install ipywidgets\n\nDefaulting to user installation because normal site-packages is not writeable\nRequirement already satisfied: branca in c:\\users\\zj1026.stu\\appdata\\roaming\\python\\python311\\site-packages (0.8.2)\nRequirement already satisfied: jinja2&gt;=3 in c:\\users\\zj1026.stu\\appdata\\roaming\\python\\python311\\site-packages (from branca) (3.1.6)\nRequirement already satisfied: MarkupSafe&gt;=2.0 in c:\\program files\\arcgis\\pro\\bin\\python\\envs\\arcgispro-py3\\lib\\site-packages (from jinja2&gt;=3-&gt;branca) (3.0.2)\nimport folium\nimport geopandas as gpd\nimport pandas as pd\nimport numpy as np\nimport ipywidgets as widgets\nfrom ipywidgets import GridBox, Layout\nfrom folium.features import GeoJsonTooltip\nfrom folium.features import CustomIcon\nfrom folium.plugins import MeasureControl\nfrom IPython.display import display, clear_output, HTML\nfrom branca.colormap import LinearColormap\n# Path to shapefile + open\nDA = r\"C:\\Users\\zj1026.stu\\OneDrive - UBC\\FCOR599\\Term1Presentation\\Output_Data\\GVan_DA_Final.shp\"\ngpdDA = gpd.read_file(DA)\n# speed up calculation (from chatGPT): \ngpdDA = gpdDA.drop(columns=[\"DGUID\",\"PRUID\",\"LANDAREA\"])\ngpdDA[\"geometry\"] = gpdDA.geometry.simplify(20, preserve_topology=True) # preserve_topology=True to avoid self-intersection issues.\n# do this before reprojection otherwise the 20 will be in degree, not in meters\n\nID = \"DAUID\" # ID column\n\n# Reprojection\nif gpdDA.crs is not None and gpdDA.crs.to_epsg() != 4326:\n    gpdDA = gpdDA.to_crs(epsg=4326)\n\ngpdDA[\"centroid\"] = gpdDA.geometry.centroid # do the centroid after the reprojection to get the correct position for centroid points, \n# because it's basically a calculated coordinate for the geometry that you already have. if you do this before reprojection, the geometry shift while the coordiates remains the same as before reprojection\n\n# Define criteria \ncriteria = ['CBDDis','StopDis','popdensity','H_maintain','H_rent','green_dens','H_edu','Age_','Unemploy_R','MedianInc','DIST_Coast','dis_scho','dis_medi','SurfaceT','PM2_5_Mean','CrimeRate']\ncost_criteria = ['StopDis','H_maintain','H_rent','Unemploy_R','dis_scho','dis_medi','SurfaceT','PM2_5_Mean','CrimeRate']  # currently all are \"the smaller, the better\"\nbenefit_criteria = ['green_dens','H_edu'] \nunknown_criteria = ['CBDDis','popdensity','Age_','MedianInc','DIST_Coast']\n\nC:\\Users\\zj1026.stu\\AppData\\Local\\Temp\\ipykernel_25092\\1829373680.py:15: UserWarning: Geometry is in a geographic CRS. Results from 'centroid' are likely incorrect. Use 'GeoSeries.to_crs()' to re-project geometries to a projected CRS before this operation.\n\n  gpdDA[\"centroid\"] = gpdDA.geometry.centroid # do the centroid after the reprojection to get the correct position for centroid points,\ngpdDA\n\n\n\n\n\n\n\n\nDAUID\nStopDis\nCBDDis\nH_maintain\nH_rent\npopdensity\ngreen_dens\nH_edu\nAge_\nUnemploy_R\n...\nDIST_Coast\ndis_scho\ndis_medi\nSurfaceT\nPM2_5_Mean\nCrimeRate\nShape_Leng\nShape_Area\ngeometry\ncentroid\n\n\n\n\n0\n59150004\n299.15\n8920.30\n2950.47\n2860.02\n425.0\n0.12\n150\n52\n6\n...\n2.99\n12956.48\n4629.36\n25.65\n3.83\n2.57e-03\n11483.58\n8.51e+05\nPOLYGON ((-123.27497 49.36885, -123.27552 49.3...\nPOINT (-123.25834 49.38879)\n\n\n1\n59150005\n76.09\n8742.44\n2320.00\n1920.00\n3168.7\n0.11\n145\n43\n7\n...\n425.38\n11200.47\n3181.21\n30.45\n3.83\n1.32e-02\n2038.22\n1.66e+05\nPOLYGON ((-123.27552 49.36948, -123.27603 49.3...\nPOINT (-123.27675 49.37161)\n\n\n2\n59150006\n135.77\n8984.06\n2680.00\n1280.00\n2899.3\n0.14\n195\n44\n12\n...\n324.34\n11333.97\n3389.08\n29.87\n3.83\n1.40e-02\n2495.17\n1.56e+05\nPOLYGON ((-123.27673 49.37536, -123.2776 49.37...\nPOINT (-123.28009 49.37237)\n\n\n3\n59150007\n509.44\n9373.56\n2701.37\n1771.88\n755.8\n0.12\n240\n49\n7\n...\n220.31\n11665.32\n3770.47\n26.81\n3.83\n3.03e-03\n6335.65\n7.21e+05\nMULTIPOLYGON (((-123.29247 49.36949, -123.2927...\nPOINT (-123.28367 49.37494)\n\n\n4\n59150008\n373.90\n8234.88\n3046.36\n2619.72\n903.0\n0.11\n275\n46\n0\n...\n316.39\n9849.44\n2148.98\n27.66\n3.83\n3.31e-03\n12275.26\n6.59e+05\nMULTIPOLYGON (((-123.27642 49.35336, -123.2770...\nPOINT (-123.27685 49.35921)\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n3586\n59154402\n102.02\n0.00\n1300.00\n1360.00\n2283.4\n0.02\n15\n60\n0\n...\n4999.88\n3554.52\n99.80\n36.17\n3.73\n1.92e-02\n1729.33\n1.49e+05\nPOLYGON ((-122.77529 49.2552, -122.77855 49.25...\nPOINT (-122.77694 49.25803)\n\n\n3587\n59154404\n235.01\n1628.23\n1360.00\n940.00\n204.2\n0.02\n40\n43\n11\n...\n6776.15\n4126.67\n1361.05\n34.51\n3.73\n8.88e-04\n11095.24\n3.22e+06\nPOLYGON ((-122.77943 49.26455, -122.73382 49.2...\nPOINT (-122.75685 49.24899)\n\n\n3588\n59154406\n272.17\n5891.70\n2140.00\n2200.00\n974.5\n0.13\n295\n42\n7\n...\n940.54\n4130.24\n3611.78\n29.01\n3.83\n3.40e-03\n3982.20\n8.09e+05\nPOLYGON ((-122.96783 49.31601, -122.95554 49.3...\nPOINT (-122.96301 49.31171)\n\n\n3589\n59154407\n285.93\n4946.32\n2155.82\n1782.38\n2123.3\n0.11\n870\n42\n8\n...\n248.73\n3075.93\n3328.46\n28.69\n3.83\n2.46e-03\n5092.12\n1.12e+06\nPOLYGON ((-122.9912 49.31287, -122.96894 49.31...\nPOINT (-122.97872 49.3094)\n\n\n3590\n59310221\n0.00\n18538.11\n2650.57\n3383.75\n0.0\n0.15\n0\n0\n0\n...\n4687.46\n20181.02\n16077.75\n25.65\n3.69\n5.28e-03\n22380.10\n7.42e+05\nMULTIPOLYGON (((-123.10277 49.48278, -123.1028...\nPOINT (-123.17919 49.48331)\n\n\n\n\n3591 rows √ó 21 columns"
  },
  {
    "objectID": "Maps_Kelvin/Map_Data/FinalMap.html#slider-weight-control",
    "href": "Maps_Kelvin/Map_Data/FinalMap.html#slider-weight-control",
    "title": "Set up + Load Data ##",
    "section": "Slider + Weight Control",
    "text": "Slider + Weight Control\n\n# Sliders: 0‚Äì10 where 0 = doesn't care, 10 = very important\nlabel = ['Distance to CBD (m)', 'Distance to Transit Stations (m)', 'Population Density','Owned House Maintainance fee ($)',\n         'House Rent ($)','Green Density','Percentage of Bachelor Degree Holders','Age','Unemployment Rate', 'Median Income ($)',\n         'Distance to Seashore (m)', 'Distance to Nearest School (m)', 'Distance to Hospital (m)', 'Surface Temperatrue (¬∞C)', \n         'PM2.5 Concentration (Œºg/m¬≥)','Crime Rate (/m¬≤)']\n# update mandatory!!!!!!\n\nsliders = {c: widgets.IntSlider(value=1,  # default equal importance. c: is the key\n                                min=0,\n                                max=10,\n                                step=1,\n                                description=l, #slider label, not the dic key\n                                continuous_update=False,\n                                style={\"description_width\": \"250px\"},\n                                layout=widgets.Layout(width=\"600px\",border=\"2px solid #0ABAB5\",padding=\"5px\",margin=\"5px\")) for c,l in zip(criteria,label)} # output:dictionary\nslider_format = GridBox(list(sliders.values()), layout=Layout(grid_template_columns=\"repeat(2, 600px)\", # 2 columns, 600px each cell\n                                                             grid_gap=\"0px 20px\", #row gap, col gap\n                                                             justify_items=\"center\"))\n\n\n# toggle options:\nlabel_unknown = ['Distance to CBD:', 'Population Density:','Average Age:','Median Income:',\n                 'Distance to Seashore']\n# update mandatory!!!!!!\ntoggles = {f\"{c}_pref\": widgets.ToggleButtons(options=[('Lower','lower'),('Higher','higher')],\n                                       value = 'lower',\n                                       description=l,\n                                       style={\"description_width\": \"50px\"},\n                                       layout=widgets.Layout(width=\"180px\",border=\"2px solid #0ABAB5\",padding=\"5px\",margin=\"5px\")) for c,l in zip(unknown_criteria,label_unknown)}\n\n\n# arrange the sliders and the toggles\nsliders_box = widgets.VBox([widgets.HTML(\"&lt;h3&gt;Set Preference for Each Criterion (0‚Äì10)&lt;/h3&gt;\"),\n                            slider_format,\n                            widgets.HTML(\"&lt;h3&gt;Decide Your Preference:&lt;/h3&gt;\"),\n                            widgets.HBox(list(toggles.values()))]) # list() to make it save, sometimes Hbox doesn't take dictionary as an input, but only iterable object like list.\n                            # put widgets.Hbox() inside to make sure there is only one toggle frame and it's list in: Vertical Vertical ... last item-&gt;horizontal \noutput = widgets.Output()\n\n\n# preview the slider bar\n# display(sliders_box)"
  },
  {
    "objectID": "Maps_Kelvin/Map_Data/FinalMap.html#normalize-criteria-compute-suitability",
    "href": "Maps_Kelvin/Map_Data/FinalMap.html#normalize-criteria-compute-suitability",
    "title": "Set up + Load Data ##",
    "section": "Normalize Criteria & Compute Suitability",
    "text": "Normalize Criteria & Compute Suitability\n\ndef compute_suitability(df, weight, preference_value):\n    df = df.copy()\n\n    # Normalize weights to 0‚Äì100% \n    totalweight = sum(weight.values()) # the result of dragging slider bar is also a dictionary\n    if totalweight == 0:\n        n = len(weight)\n        weight_norm = {c: 1 / n for c in weight} # if 0 for all, then use default where each criterion get the same weight\n    else:\n        weight_norm = {c: v / totalweight for c, v in weight.items()}\n    weight_percent = {c: 100 * w for c, w in weight_norm.items()}\n\n\n    # Normalize each criterion to 0-1\n    for col in criteria:\n        vals = df[col].astype(float) # get the entire column from the df, based on the name of col\n        vmin, vmax = vals.min(), vals.max() # get the extent of the column\n\n        if vmax == vmin:\n            df[col + \"_norm\"] = 0.0 # fill 0 to all rows if the extent is 0 as well. \n            continue\n\n        # decide if CBD is cost/benefit\n        if col in unknown_criteria:\n            user_pref = preference_value[col]\n            if user_pref == 'lower':\n                df[col + \"_norm\"] = (vmax - vals) / (vmax - vmin)\n            else:\n                df[col + \"_norm\"] = (vals - vmin) / (vmax - vmin)\n\n        # for other normal criteria\n        elif col in cost_criteria:\n            # if the criterion is better when the number is small (cost)\n            df[col + \"_norm\"] = (vmax - vals) / (vmax - vmin)\n        else:\n            # if the criterion is better when the number is large (benifit)\n            df[col + \"_norm\"] = (vals - vmin) / (vmax - vmin)\n\n    # Calculate suitability score\n    df[\"suit_score\"] = sum(df[c + \"_norm\"] * weight_norm[c] for c in criteria)\n\n    return df, weight_norm, weight_percent"
  },
  {
    "objectID": "Maps_Kelvin/Map_Data/FinalMap.html#build-interactive-map-function",
    "href": "Maps_Kelvin/Map_Data/FinalMap.html#build-interactive-map-function",
    "title": "Set up + Load Data ##",
    "section": "Build Interactive Map Function",
    "text": "Build Interactive Map Function\n\n# get the map center\ncenter_y = gpdDA.geometry.centroid.y.mean()\ncenter_x = gpdDA.geometry.centroid.x.mean()\n# Hover tooltip: ID, score, and raw criterion values\ntooltip_fields = [ID, \"suit_score\"] + criteria\ntooltip_aliases = [ID, \"Suitability Score\"] + label \n\ndef update_map(**all_inputs): # accept any length of the input as keyword arguments( a=1; b=2; c....), then transform it into a dictionary, so weight will be interpretate as an dictionary\n    with output: # printed or displayed inside this block goes into the Output widget, so everything below is incorporated into the widget window, not a jupyter cell.\n        clear_output() # clear everything before (each movement of the slider actually produce one map, so clear it before get the final map), also see rational below\n\n        weight = {c: all_inputs[c] for c in criteria}\n        preference_value = {c: all_inputs[f\"{c}_pref\"] for c in unknown_criteria}\n\n        # call function above to get the all necessary results:\n        df_score, weight_norm, weight_percent = compute_suitability(gpdDA, weight, preference_value)\n\n        #rank + slcie the top 10 most promising living site \n        sorted_score = df_score.sort_values(\"suit_score\", ascending=False)\n        top10 = sorted_score.head(10).copy()\n        \n        top10[\"Rank\"] = np.arange(1, len(top10) + 1)      \n        # get the summary table for top 10\n        cols_for_table = [\"Rank\", ID, \"suit_score\"] + criteria\n        summary_table = top10[cols_for_table].copy()\n        summary_table = summary_table.sort_values(\"Rank\")\n\n\n        # print normalized weights just for reference\n        print(\"Normalized weights (auto-scaled to sum to 100%):\")\n        nw = '|'.join([f\"  {c}: {weight_percent[c]:.1f}%\" for c in criteria])\n        print(nw)\n            # 10 & 5 = width; .1 = preserve 1 decimal after the point; s = string; f = float, c: & weight_percent[c]: = define the format of this item for me \n        \n        # Basemap\n        m = folium.Map(location=[center_y, center_x],\n                       zoom_start=10.5,\n                       tiles='https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', \n                       # https://leaflet-extras.github.io/leaflet-providers/preview/\n                       # all possible tiles to choose \n                       attr='CartoDB.Voyager', \n                       max_zoom=20)\n        # measuring tool\n        MeasureControl(position='bottomleft',\n                       primary_length_unit='meters',\n                       secondary_length_unit='kilometers').add_to(m)\n        \n        # Choropleth based on suitability score\n        linear = LinearColormap([\"#4281a4\", \"#9cafb7\", \"#ead2ac\", \"#e6b89c\", \"#fe938c\"], \n                                vmin=df_score[\"suit_score\"].min(), \n                                vmax=df_score[\"suit_score\"].max(), \n                                caption = \"Suitability Score\").add_to(m)\n        # modify the choropleth map + adding tooltip\n        df_for_map = df_score.drop(columns=[\"centroid\"])\n        folium.GeoJson(\n            df_for_map,\n            name=\"Info\",\n            style_function=lambda feature: {\"color\": \"black\", # outline/border color\n                                            \"fillColor\": linear(feature['properties']['suit_score']), # GeoJSON dataframe = feature[\"properties\"] + feature[\"geometry\"]\n                                            \"weight\": 0.3,\n                                            \"fillOpacity\": 0.8},\n            tooltip=GeoJsonTooltip(fields=tooltip_fields,\n                                   aliases=tooltip_aliases,\n                                   localize=True, # format the numbers well: adds commas + format float + respects locale settings (round up is no space)\n                                   sticky=False)).add_to(m)  # disapper if cursor move off the polygon\n\n        \n        # Mark top 10 DA centroids in red\n        for _, row in top10.iterrows(): # .iterrows()loop through a pandas DataFrame row by row. return index + row content \n            #_ = i dont care, so here means I don't care the index.\n            c = row.centroid\n            popup = f\"\"\"\n            &lt;div style=\" font-size:14px; padding:8px; background-color:#ffe8c1; border-radius:8px; border: 2px solid #555\"&gt;\n            &lt;b&gt; Most Suitable Place to Live Number #{int(row['Rank'])}&lt;/b&gt;&lt;br&gt;\n            &lt;b&gt;{ID}&lt;/b&gt;: {row[ID]}&lt;br&gt;\n            &lt;b&gt;Suitability Score&lt;/b&gt;: {row['suit_score']:.3f}&lt;br&gt;\n            &lt;br&gt;\n            &lt;b&gt;Distance to CBD (m)&lt;/b&gt;: {row['CBDDis']}&lt;br&gt;\n            &lt;b&gt;Distance to Public Transportation (m)&lt;/b&gt;: {row['StopDis']}&lt;br&gt;\n            &lt;b&gt;Population Density&lt;/b&gt;: {row['popdensity']}&lt;br&gt;\n            &lt;b&gt;Owned House Maintainance fee ($)&lt;/b&gt;: {row['H_maintain']}&lt;br&gt;\n            &lt;b&gt;House Rent ($)&lt;/b&gt;: {row['H_rent']}&lt;br&gt;\n            &lt;b&gt;Green Density&lt;/b&gt;: {row['green_dens']}&lt;br&gt;\n            &lt;b&gt;Percentage of Bachelor Degree Holders&lt;/b&gt;: {row['H_edu']}&lt;br&gt;\n            &lt;b&gt;Age&lt;/b&gt;: {row['Age_']}&lt;br&gt;\n            &lt;b&gt;Unemployment Rate&lt;/b&gt;: {row['Unemploy_R']}&lt;br&gt;\n            &lt;b&gt;Median Income&lt;/b&gt;: {row['MedianInc']}&lt;br&gt;\n            &lt;b&gt;Distance to Seashore&lt;/b&gt;: {row['DIST_Coast']}&lt;br&gt;\n            &lt;b&gt;Distance to Nearest School&lt;/b&gt;: {row['dis_scho']}&lt;br&gt;\n            &lt;b&gt;Distance to Hospital&lt;/b&gt;: {row['dis_medi']}&lt;br&gt;\n            &lt;b&gt;Surface Temperatrue (¬∞C)&lt;/b&gt;: {row['SurfaceT']}&lt;br&gt;\n            &lt;b&gt;PM2.5 Concentration (Œºg/m¬≥)&lt;/b&gt;: {row['PM2_5_Mean']}&lt;br&gt;\n            &lt;b&gt;Crime Rate (/m¬≤)&lt;/b&gt;: {row['CrimeRate']}&lt;br&gt;\n            &lt;/div&gt;\n            \"\"\"\n            popup_text = folium.Popup(popup, max_width = '400')\n\n            folium.Marker(location=[c.y, c.x],\n                          popup=popup_text,\n                          icon=folium.DivIcon(\n                              html=\"\"\"\n                              &lt;div style=\"font-size:20px; \n                              line-height:40px; \n                              transform: translate(-50%, -50%);\"&gt;üèµÔ∏è&lt;/div&gt;\n                              \"\"\")).add_to(m)\n            # text-shadow: 0 0 5px #ead2ac, 0 0 8px #9cafb7, 0 0 15px #4281a4;  for shadow, 008pxgold -&gt; 00 shift in x&y, size, color\n            # line-height: control the invisible sqaure that contain the emoji, transform: translate(-50%, -50%), put the image at centre, default is top-left corner\n        \n        # print map\n        display(m)\n        \n        print(\"\\nTop 10 most suitable dissemination areas:\")\n        summary_table.columns = ([\"Rank\", \"DAUID\", \"Suitability Score\"] + label)  # existing list of 5 nicely formatted names\n        # set the dataframe format\n        pd.set_option(\"display.precision\", 2)\n        pd.set_option(\"display.width\", 2000)\n        display(summary_table)\n\nC:\\Users\\zj1026.stu\\AppData\\Local\\Temp\\ipykernel_25092\\1173824240.py:2: UserWarning: Geometry is in a geographic CRS. Results from 'centroid' are likely incorrect. Use 'GeoSeries.to_crs()' to re-project geometries to a projected CRS before this operation.\n\n  center_y = gpdDA.geometry.centroid.y.mean()\nC:\\Users\\zj1026.stu\\AppData\\Local\\Temp\\ipykernel_25092\\1173824240.py:3: UserWarning: Geometry is in a geographic CRS. Results from 'centroid' are likely incorrect. Use 'GeoSeries.to_crs()' to re-project geometries to a projected CRS before this operation.\n\n  center_x = gpdDA.geometry.centroid.x.mean()"
  },
  {
    "objectID": "Maps_Kelvin/Map_Data/FinalMap.html#connect-map-control-panel-display-the-map",
    "href": "Maps_Kelvin/Map_Data/FinalMap.html#connect-map-control-panel-display-the-map",
    "title": "Set up + Load Data ##",
    "section": "Connect Map & Control Panel  + Display the Map",
    "text": "Connect Map & Control Panel  + Display the Map\n\ninteractive = widgets.interactive_output(update_map, {**sliders, **toggles}) # build connection between the slider bar and the map, so that's how the change in the slider actually affect the map display\n# however, that means everytime we adjust the slider, a new set of values are put into the function, so the whole function will run again. that's why we need a clear_output() above.\n# widgets.interactive_output(function, controls) where controls MUST be a DICTIONARY, the function will know how to match the parameters by the KEYs in the control dictionary. \ndisplay(sliders_box, output) # show slider_box and the output(map + table) in sequence"
  }
]